# 2025.01.20
'''
파이썬은 지켜야 할 문법이 적은게 특징이다.
C나 자바에 비해 좋다.
파이썬은 인터프리터 언어이다.
자료형 인티저, 플로트, 스트링 배웠다.
자료를 저장할 때, C언어의 포인터와 비슷하다. 그 값을 직접 저장하는 것이 아니라 주솟값을 저장하는 개념이다.
플로트에서 근삿값을 사용하기 떄문에 발생하는 플로팅 에러 주의하자.
스트링은 중간값을 변경할 수 없다.
슬라이싱할 때, 콜론 뒤의 숫자에 유의하자. 처음꺼 이상, 두번째꺼 미만이다.
기본 한줄 주석은 #
여러줄 주석은 드래그하고 Ctrl + /
'''

# 2025.01.21
'''
자료형 중 가장 많이 쓰는 것 : 리스트, 딕셔너리
리스트, 튜플, 레인지, 딕셔너리, 세트, None, Boolean
형변환
'''

# 2025.01.22
# 함수 선언
def function_namee():
    """
    docs
    """
    function_act
    return
'''
반롼값이 없는 함수도 있다.

parameter : 함수를 선언할 때
argument : 함수를 호출할 때

함수의 인자들의 종류가 여러가지 있다. 아예 신경 안쓰진 말자.
위치인자 : 그 위치에 있는 인자로 저장됨
기본인자 : 함수를 선언하며 default값을 넣어줄 수 있다. 입력을 생략하면 디폴트값이 들어간다.
키워드인자 : 함수를 호출할 때 키워드에 값을 직접 넣을 수 있다. 대신 위치인자보다 뒤에만 존재해야 한다. 앞에 넣고 뒤에는 위치인자 넣으면 안된다.
임의의, 임의의키워드 인자 : 여러 개가 들어올 때 쓴다.

기본적으로 함수는 하나의 명령만 수행하도록 만들어야 한다. 인자가 너무 많다면 필요없는 인자가 있거나, 함수가 복잡해지고 있지는 않은지 살펴보자.

재귀함수는 알고리즘 공부할 때 많이 나올듯.

외부에 있는 변수를 함수 내부에서 수정하려면 global로 선언 후 수정한다.
'''

# 2025.01.23
'''
반복문, 조건문
반복 : for, while
'''
for x in y:
    pass
'''
y 안에 있는 요소들을 x로 반환하여 반복한다는 뜻. y는 시퀀스형 자료처럼 순서가 있을 수 있고, 딕셔너리처럼 없어도 된다.
중첩해서 쓸 수도 있고, 그러면 matrix처럼 보이기도 한다.
'''
while x:
    pass
'''
x 에 조건이 들어간다. 이 조건이 참일 경우 반복하고 거짓일 경우 while문 밖으로 나간다.
반드시 그 조건을 거짓으로 만들도록 하는 명령이 있어야 한다.
break는 그 반복을 멈춘다. 리스트에 찾고자 하는 요소를 찾는 경우처럼 쓰인다.
continue는 다음 반복으로 넘어간다. 리스트에서 짝수만 찾아서 값을 출력한다던가 하는 경우에 쓰인다.
pass는 아무 역할도 하지 않는다. 보통 미완성된 함수에서 그냥 코드를 돌려볼 때 쓰는 것 같다.
'''
'''
조건 : if, elif, else
특별한 것은 없다. C언어의 if, else if, else 와 완벽히 같은 역할을 한다.
'''

# 2025.01.24
'''
메서드 : 클래스가 자체적으로 가진 내장함수라고 이해하면 될 것 같다.
스트링은 스트링대로, 리스트는 리스트대로, 딕셔너리는 딕셔너리대로 각각의 메서드를 갖고 있으니 헷갈리지 않도록 하자.
자료형 잘 확인하면서 메서드를 사용하면 그동안 풀지 못했던 문제들을 풀 수 있을 것이다.
'''

# 2025.01.31
# 딕셔너리에 키 바로 넣기
old_dict = {'key1':'value1'}
new_dict = {
    'key2': old_dict.get('key1'),
    'key3': 'value3',
}
'''
서버에서 API 받아서 데이터로 사용하기
$ pip install requests
json 형식으로 받는데, 대부분 딕셔너리를 요소로 하는 리스트의 형태다. 이걸 잘 받아서 가공하여 쓰면 된다.
'''

# 2025.02.01
# 딕셔너리로 이루어진 리스트에서, 딕셔너리의 밸류를 기준으로 정렬하는 법

data = [
    {
        'name': 'Alex',
        'age': 30,
    },
    {
        'name': 'Brad',
        'age': 25,
    },
    {
        'name': 'Chad',
        'age': 35,
    },
]
result = sorted(data, key=lambda x:x['age'])
# sorted(iterable, key=None, reverse=False)
# sorted 함수의 key에 비교할 기준을 정하는 함수를 넣을 수 있다. 한번만 쓰므로 람다함수로 표현하는 것이 가독성에 좋을 것 같다.
# 순환가능한 자료인 data를 정렬하는데, 정렬할 요소는 딕셔너리이다. key 뒤의 람다함수는 "정렬할 기준이 각 딕셔너리의 'age'라는 key로 접근하여 얻은 value이다." 라고 표현하는 것이다.
# result는 오름차순으로 정렬되어 Brad, Alex, Chad 의 순서로 정렬될 것이다.


# 2025.02.03
# 클래스
class MyClass: # 클래스 이름은 대문자로 띄어쓰기 구분하는 파스칼 케이스스
    int_var = 0 # 클래스 변수
    set_var = set() # 클래스 변수는 변수로 쓸 수 있는 모든 데이터타입을 사용 가능

    def __init__(self, arg1, arg2): # 언더스코어 두개로 쌓인 매직 메서드는 특별한 상황에 자동으로 호출
        # init의 경우 클래스의 인스턴스를 처음 선언할 때 실행됨. (생성자 메서드드)
        # self는 본인을 갖다 쓴다는 뜻, OOP(객체 지향)으로 가다보니 쓰이게 됨
        self.arg1 = arg1
        self.arg2 = arg2
        # 이 클래스의 인스턴스를 선언하며 받은 인자를 독립적인 인스턴스 변수로 사용
        MyClass.int_var_add()
        MyClass.set_var_add(arg1)
        # 인스턴스를 생성하며 클래스 메서드 사용.

    def changer(self): # 인스턴스 메서드. 인스턴스 변수를 사용하여 동작하는 메서드이다.
        temp = self.arg1
        self.arg1 = self.arg2
        self.arg2 = temp

    @classmethod # 데코레이터, 클래스메서드와 스태틱메서드를 생성할 때 넣어줘야 한다.
    def int_var_add(cls): # 클래스메서드는 self가 아닌 cls로 쓴다.
        cls.int_var += 1

    @classmethod
    def set_var_add(cls, arg):
        cls.set_var.add(arg)
    
    @staticmethod
    def adder(arg1, arg2): # 스태틱메서드는 self와 cls를 받지 않고, 받고싶은대로 받는다. 그래서 인스턴스변수와 클래스변수를 활용하지 않는다.
        return arg1 + arg2

class_example_1 = MyClass('a', 'b')
class_example_2 = MyClass(1, 2)